# 线程的实现

## 系统启动初始化

在rust_main函数中，执行了axtask::init_scheduler函数，该函数调用`run_queue::init`函数，依次执行如下步骤：

1. 创建一个`idle_task`，入口点为`run_idle`。执行该任务时会一直调用yield_now放弃调度。
2. 将`idle_task`放入IDLE_TASK中，IDLE_TASK表示闲置的任务
3. 初始化RUN_QUEUE队列，该队列是任务的执行队列，其中创建了一个gc任务，用于已退出任务的回收。
4. 创建`main_task`，并设置为Running状态，并将其作为CurrentTask，写到了CURRENT_TASK_PTR中。

任务id是从1开始自增的，不会是0；main被创建为init任务

## 线程管理相关的数据结构

线程以Pthread结构体存在：

```rust
pub struct Pthread {
    inner: AxTaskRef, // 本质上是一个TaskInner
    retval: Arc<Packet<*mut c_void>>, // 返回值，需要在多个线程之间共享
}
```

在最底层，以任务的形式存在，任务控制块为TaskInner。

任务控制块：

```rust
/// The inner task structure.
pub struct TaskInner {
    id: TaskId,
    name: String,
    is_idle: bool,
    is_init: bool,

    entry: Option<*mut dyn FnOnce()>,
    state: AtomicU8,

    in_wait_queue: AtomicBool, // 是否在等待队列中
    #[cfg(feature = "irq")]
    in_timer_list: AtomicBool,

    #[cfg(feature = "preempt")]
    need_resched: AtomicBool,
    #[cfg(feature = "preempt")]
    preempt_disable_count: AtomicUsize,

    exit_code: AtomicI32,
    wait_for_exit: WaitQueue,
	// 采用RAII思想，drop taskinner的时候就会自动回收栈
    kstack: Option<TaskStack>,
    ctx: UnsafeCell<TaskContext>,

    #[cfg(feature = "tls")]
    tls: TlsArea,
}
```

任务栈：

```rust
struct TaskStack {
    ptr: NonNull<u8>, // 栈最低地址的指针
    layout: Layout,	  // 栈的布局，包括大小、对齐
}
```

任务上下文：

任务上下文初始化时，指定的ra地址为task_entry。

## 接口函数

### pthread_create

接收四个参数，其中res表示线程start_routine为线程要执行的函数，arg为函数参数

```rust
pub unsafe extern "C" fn ax_pthread_create(
    res: *mut ctypes::pthread_t,
    attr: *const ctypes::pthread_attr_t,
    start_routine: extern "C" fn(arg: *mut c_void) -> *mut c_void,
    arg: *mut c_void,
) -> c_int
```

该函数向下调用了Pthread::create函数，并将Pthread的指针形式写入res。暂时没管attr。

* Pthread::create

该函数根据start_routine创建了一个新的任务，并将该任务放入RUN_QUEUE中。基于该任务又创建了Pthread，并写入了TID_TO_PTHREAD中，构建了tid与thread的映射关系。返回值为Pthread的指针形式

### pthread_exit

```rust
fn ax_pthread_exit(retval: *mut c_void)
```

执行该函数的线程会被退出，其中retval指向了其退出值所在的内存位置。

首先会把retval保存在thread的retval中，然后执行RUN_QUEUE的exit_current函数。该函数判断：

1. 如果当前任务是初始任务，例如main，直接杀掉整个系统
2. 标记当前任务为Exited，并唤醒所有等待该任务结束的线程，将当前任务推入EXITED_TASKS，并唤醒一个WAIT_FOR_EXIT队列中的线程。
3. 执行RUN_QUEUE的**resched函数**，将当前任务记为prev，从RUN_QUEUE中取出一个可以调度的任务作为next（如果不存在则将IDLE_TASK作为next），执行switch_to函数。

* `AxRunQueue::switch_to`函数：

将next任务设为当前任务，将prev上下文保存到TaskContext中，并将next的上下文TaskContext恢复到CPU中，然后跳转到ra寄存器指向的地址。在TaskContext初始化函数Init中，设置了ra为程序entry。

注意，RUN_QUEUE的resched函数就是重新调度函数。

### pthread_join

```c
int pthread_join(pthread_t thread, void **retval);
```

该函数向下调用Pthread::join函数，通过block_current函数将当前任务加入到要join任务的wait_for_exit队列中，并resched。

当要jion任务结束后，该线程重新被调度时，将该线程恢复，不过线程恢复是在wait_until函数loop循环中，因此会检查是否满足condition，如果不满足还是会被阻塞。

### pthread_mutex_init

```rust
pub unsafe extern "C" fn ax_pthread_mutex_init(
    mutex: *mut ctypes::pthread_mutex_t,
    _attr: *const ctypes::pthread_mutexattr_t,
) -> c_int
```

初始化一个锁，忽略_attr。mutex是PthreadMutex的指针。

```rust
pub struct PthreadMutex(Mutex<()>);
```

* Mutex

Mutex则是在axstd中定义的：

```rust
pub struct Mutex<T: ?Sized> {
    wq: AxWaitQueueHandle,
    owner_id: AtomicU64,
    data: UnsafeCell<T>,
}
```

它实现了Sync和Send。

其中wait_queue提供了wait和wake方法。

### pthread_mutex_lock

```rust
fn ax_pthread_mutex_lock(mutex: *mut ctypes::pthread_mutex_t) -> c_int
```

加锁，调用了PthreadMutex的lock函数，该函数向下调用Mutex的lock函数。该函数返回一个MutexGuard，它实现了Drop trait，当drop时会自动调用锁的unlock函数释放锁，在rust应用程序中用到了。

```rust
pub struct MutexGuard<'a, T: ?Sized + 'a> {
    lock: &'a Mutex<T>,
    data: *mut T,
}
```

### pthread_mutex_unlock

```rust
ax_pthread_mutex_unlock(mutex: *mut ctypes::pthread_mutex_t) -> c_int
```

解锁， 会调用mutex的force_unlock函数，该函数将锁的owner_id设置为0，并唤醒锁中等待队列的一个任务，将其加入调度器，并设置状态为Ready。

## 我的实现

### trylock

和lock失败被阻塞不同，trylock成功则获得锁，否则errno为EBUSY。

实现方式：直接调用mutex的try_lock函数。

### pthread_cancel

```rust
int pthread_cancel(pthread_t thread);
```

一个线程通过该函数向另一个线程发送“终止执行”的信号，从而令目标线程结束执行。

返回值：成功返回0，否则返回非0

> 参数 thread 用于指定被取消的线程。另外，一个线程是否会被取消**取决于**该线程的`cancelability state and type.`
>
> 执行该函数时，首先检查state，如果state为enabled（默认），则检查type。如果为disabled，则cancel请求排队直到state为enabled。state可以通过函数**pthread_setcancelstate**设置
>
> 其次检查type，可能为asynchronous或deferred（默认）。如果为前者则立即取消，如果为deferred则直到线程调用cancellation point函数(见pthread(7))(才会cancel。type可以通过**pthread_setcanceltype**函数修改。
>
> cancellation point有很多，目前就实现这一个吧：`pthread_testcancel`
>
> 被取消的线程相当于执行`pthread_exit(PTHREAD_CANCELED);`，也就是说，他会给`join`到自己的函数返回一个`PTHREAD_CANCELED`的返回值。

取消线程的实现思路：

线程共有4种状态，Running，Ready，Blocked，Exited。

Running就是取消自身，好实现（多核CPU就不好说了吧）

Ready就是在AX_RUN_QUEUE中，也好实现应该

```
// TaskInner中
curr.set_state(TaskState::Exited);   
curr.notify_exit(exit_code, self);
EXITED_TASKS.lock().push_back(curr.clone());

```

Blocked：

EXITED：不需要取消了

### pthread_testcancel

```c
void pthread_testcancel(void);
```

### pthread_setcancelstate

```c
int pthread_setcancelstate(int state, int *oldstate);
```

### pthread_setcanceltype

```c
int pthread_setcanceltype(int type, int *oldtype);
```

暂时不做这个函数了。因为取消一个别的线程有些困难还，默认就是deferred取消。

取消当前线程：

### 条件变量的实现

检查C和Rust的大小是否对应：

```rust
use core::mem::{size_of, ManuallyDrop};
static_assertions::const_assert_eq!(
    size_of::<PthreadMutex>(),
    size_of::<ctypes::pthread_mutex_t>()
);
```



### pthread_cond_init函数

条件变量必须总是和mutex一起使用。

```c
int pthread_cond_init(pthread_cond_t *cond, pthread_condattr_t *cond_attr);
```

初始化一个条件变量cond，忽略attr。

* relibc

```rust
pub struct Cond {
    cur: AtomicUint,
    prev: AtomicUint,
}
pub fn new() -> Self {
    Self {
        cur: AtomicUint::new(0),
        prev: AtomicUint::new(0),
    }
}
```

### pthread_cond_signal

```c
int pthread_cond_signal(pthread_cond_t *cond);
```

唤醒一个正在等待条件变量的线程。如果没有线程等待，什么也不会发生；如果有多个线程等待，则只能有一个被唤醒。

```rust
fn wake(&self, count: i32) -> Result<(), Errno> {
    // This is formally correct as long as we don't have more than u32::MAX threads.
    let prev = self.prev.load(Ordering::Relaxed);
    self.cur.store(prev.wrapping_add(1), Ordering::Relaxed);

    crate::sync::futex_wake(&self.cur, count);
    Ok(())
}
pub fn futex_wake(atomic: &impl FutexAtomicTy, n: i32) -> usize {
    unsafe { futex_wake_ptr(atomic.ptr(), n) }
}
pub unsafe fn futex_wake_ptr(ptr: *mut impl FutexTy, n: i32) -> usize {
    // TODO: unwrap_unchecked?
    Sys::futex(ptr.cast(), FUTEX_WAKE, n, 0).unwrap() as usize
}
```



### pthread_cond_wait

```c
int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
```

pthread_cond_wait会自动解锁mutex，并等待条件变量cond直到它被signal。在被唤醒后返回执行时，wait再次获得锁。

```rust
pub fn wait(&self, mutex: &RlctMutex) -> Result<(), Errno> {
    self.wait_inner(mutex, None)
}
fn wait_inner(&self, mutex: &RlctMutex, timeout: Option<&timespec>) -> Result<(), Errno> {
    self.wait_inner_generic(
        || mutex.unlock(),
        || mutex.lock(),
        |timeout| mutex.lock_with_timeout(timeout),
        timeout,
    )
}
fn wait_inner_generic(
    &self,
    unlock: impl FnOnce() -> Result<()>,
    lock: impl FnOnce() -> Result<()>,
    lock_with_timeout: impl FnOnce(&timespec) -> Result<()>,
    timeout: Option<&timespec>,
) -> Result<(), Errno> {
    // TODO: Error checking for certain types (i.e. robust and errorcheck) of mutexes, e.g. if the
    // mutex is not locked.
    let current = self.cur.load(Ordering::Relaxed);
    self.prev.store(current, Ordering::Relaxed);
	// 释放锁
    unlock();
    crate::sync::futex_wait(&self.cur, current, None);
    // 加锁
    lock();
    Ok(())
}
pub fn futex_wait<T: FutexAtomicTy>(
    atomic: &T,
    value: T::Ty,
    timeout_opt: Option<&timespec>,
) -> bool {
    unsafe { futex_wait_ptr(atomic.ptr(), value, timeout_opt) }
}
```



### pthread_cond_broadcast

```c
int pthread_cond_broadcast(pthread_cond_t *cond);
```

唤醒所有等待条件变量的线程。

## 问题

- [x] 多线程是主动yield还是有时钟中断？

这之间的调度应该就是通过join来yield来调度的。是的，**光有multitask是不会抢占调度的**。

- [ ] PthreadMutex的lock函数创建的_guard是否永远不会释放了？

~~我觉得可以把它作为PthreadMutex的一个成员变量，执行unlock时将其drop~~

C语言创建锁你见销毁过吗？专门有个销毁函数

- [ ] Pthread为什么成员得是Atomic？

- [ ] Pthread函数发生错误时返回值需要是errno，因为会有很多个线程。而目前的实现是返回-1然后errno变量记录它们。

```rust
pub fn e(result: Result<(), pthread::Errno>) -> i32 {
    match result {
        Ok(()) => 0,
        Err(pthread::Errno(error)) => error,
    }
}
```

- [ ] Pthread如果自己执行pthread_exit，那么资源是否需要回收？按目前的实现应该是需要join函数回收，但按linux手册上应该是不用

目前的做法可能就是要保存这个retval，以便执行Join时能取到retval

- [ ] 线程只能被join一次，如果之后再被join会报错，好像没见这块的错误处理？
- [x] 为什么pthread涉及锁和条件变量函数的参数都是指针类型的？

传值代价大，传指针代价小

- [ ] 锁、条件变量销毁函数
