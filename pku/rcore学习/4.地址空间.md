# 4.地址空间

前面章节的rcore还不存在虚拟地址这个概念，访存都是通过物理地址。缺点就太多了，例如物理地址空间浪费、物理地址空间不隔离造成内核代码可能被篡改。为此产生了一种抽象，叫地址空间。

## Rust中的动态内存分配

> 本节提供了很多简洁的对智能指针、容器的介绍，可以参考。

动态内存分配就是在堆上分配空间。要在Rust中实现动态内存分配，需要使用`alloc`库提供的一系列有用的智能指针或容器：Vec、String、Box等等等等。

* 配置alloc库

而`alloc` 库需要我们提供给它一个全局的动态内存分配器，它会利用该分配器管理堆空间。该分配器需要实现`GlobalAlloc` Trait，该Trait要求必须实现：

```rust
pub unsafe fn alloc(&self, layout: Layout) -> *mut u8;
pub unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout);
```

Layout指出了分配的需求，所需空间大小size和返回地址的对齐要求align。

然后只需将我们的动态内存分配器类型实例化为一个全局变量，并使用 `#[global_allocator]` 语义项标记即可。

## 地址空间

地址空间，是内核对应用程序的一种抽象。应用程序以为自己独占整个内存空间，且应用程序看到的地址叫做虚拟地址。地址空间只是一层抽象接口，它有很多种具体的实现策略：

1. 连续内存分配：一整个程序被分配到内存中的一个位置。地址变换是线性的，内碎片严重
2. 分段内存管理：外碎片严重
3. 分页内存管理：综合前两者优点，是rcore采用的。

## SV39多级页表的硬件机制

默认情况下 MMU 未被使能。要使用MMU，则需要设置S特权级下的CSR寄存器`satp`启动分页模式，这样S和U特权级的访存地址会被视为虚拟地址。而M级的访存地址，可设定为真实物理地址。`satp`寄存器结构如下：

![../_images/satp.png](https://mdpics4lgw.oss-cn-beijing.aliyuncs.com/aliyun/202308241656043.png)

设置`stap`中`MODE`为8时，就会启动SV39分页机制。虚拟地址共39位，物理地址共56位，页内偏移均为12位。`PPN`是指多级页表根节点所在的物理页号。

页表项的结构：

![../_images/sv39-pte.png](https://mdpics4lgw.oss-cn-beijing.aliyuncs.com/aliyun/202308241622582.png)

通过bitflags可以定义页表项。

### 多级页表

如果采用线性表，那么虚拟地址共39位，页内偏移共12位，则共需要$2^{27}$个页表项，那页表体积太大了。解决办法就是按需分配，

SV39的实现是一个3级页表，虚拟页号共27位，被分为3级页索引，每个页索引占9位。

### SV39地址转换过程

![../_images/sv39-full.png](https://mdpics4lgw.oss-cn-beijing.aliyuncs.com/aliyun/202308241654695.png)

注意：

只有当 `V` 为1 且 `R/W/X` 均为 0 时，表示是一个合法的页目录表项

当 `V` 为1 且 `R/W/X` 不全为 0 时，表示是一个合法的页表项

### 快表

如果切换了进程，`satp`寄存器被修改，那么内核要在**修改 satp 的指令后面马上使用 sfence.vma 指令刷新清空整个 TLB。**

如果我们手动修改一个页表项之后，TLB 并不会自动刷新清空，我们也需要使用 sfence.vma 指令刷新整个 TLB。

注：在 sfence.vma 指令后面加上一个虚拟地址，这样只会刷新TLB中关于这个虚拟地址的单个映射项

## 管理SV39页表

### 物理页帧管理

这里需要定义一个物理页帧管理器，实现对物理页面的分配、回收。和之前的管理器一样，它也是个被UPSafeCell包裹的全局变量。

其他内核模块在调用分配/回收物理页帧的接口时，这里用到了RAII的思想。即将一个变量用一个会被自动drop的类封装，当其drop时执行对该变量的某种操作。当分配物理页帧时，返回的是FrameTracker，它包装了PhysPageNum。FrameTracker还实现了Drop特征，当被自动drop时，会将该页面归还给物理页帧管理器。

```rust
impl Drop for FrameTracker {
    fn drop(&mut self) {
        frame_dealloc(self.ppn);
    }
}
```

### 多级页表管理

通过PageTable结构体来表示一个页表，页表项所表示的物理页帧会以frames的形式存放在pageTable中，故当drop PageTable时，页表项对应的物理页面也都会被自动回收。

pageTable提供2个接口函数，map和unmap。可以将虚拟页号和物理页号进行映射，也可以解除映射。

内核如果要访问一个特定的物理地址pa，在开启分页模式后，由于CPU发出的都是虚拟地址，因此还需要构造一个pa对应的内核虚拟地址va。这里采用了最简单的**恒等映射**。

## 内核与应用的地址空间

页表PageTable只是维护了虚拟内存和物理内存的映射关系，但OS还需要全局性地对整个虚拟/物理内存空间有一个掌控和管理。这种管理是建立在地址空间抽象上的。

**地址空间** 是一系列不一定连续的逻辑段，这些逻辑段组成的虚拟地址空间和一个进程绑定。它用MemorySet类型来表示：

```rust
pub struct MemorySet {
    page_table: PageTable, // 多级页表
    areas: Vec<MapArea>, // 逻辑段
}
```

其中page_table下挂载着多级页表的所有节点所在的物理页帧FrameTracker，每个MapArea则挂着对应逻辑段中数据所在的物理页帧，这采用了RAII思想，当MemorySet生命周期结束后，所有物理页框都会被回收。一个逻辑段用MapArea来表示：

```rust
pub struct MapArea {
    vpn_range: VPNRange,// 虚拟页号的范围
    data_frames: BTreeMap<VirtPageNum, FrameTracker>, // 虚拟页号和其数据所在的物理页框的映射
    map_type: MapType, // 映射类型，恒等还是分页
    map_perm: MapPermission, // 映射权限，只读还是xxx
}
```

### 内核地址空间

内核地址空间的逻辑段，.text、.data、.bss和ekernel到MEMORY_END的区域，都以恒等映射的形式映射到了内核地址空间当中（位于new_kernel函数）。

![../_images/kernel-as-high.png](https://mdpics4lgw.oss-cn-beijing.aliyuncs.com/aliyun/202308301443792.png)

![../_images/kernel-as-low.png](https://mdpics4lgw.oss-cn-beijing.aliyuncs.com/aliyun/202308301443491.png)

### 应用地址空间

应用的各个逻辑段都是以Framed分页模式映射到物理内存。应用地址空间在创建时，通过from_elf函数来完成，其输入是由get_app_data函数将带有元数据的应用二进制执行文件转化为&[u8]数组输入的。

创建应用地址空间时，用户栈和TrapContext也被映射到了物理空间中，其中用户栈在.bss段过去一个保护页的位置，而TrapContext则位于地址空间的次高页。

![../_images/app-as-full.png](https://mdpics4lgw.oss-cn-beijing.aliyuncs.com/aliyun/202308301444533.png)

## 建立基于地址空间的分时多任务

### 建立、开启基于分页的虚拟地址空间

在KERNEL_SPACE的activate函数中，通过向satp寄存器写入内核页表的根节点的物理页号，激活分页机制，从此CPU发出的都是虚拟地址了。

* satp的切换必须是一个平滑的过渡

无论是从不分页机制转变为分页机制的切换，还是内核地址空间和用户地址空间的切换，都需要保证切换satp的指令和下一条指令的虚拟地址是相邻的。因为切换指令不是跳转指令，pc寄存器只是简单地+4.

### 跳板机制的实现

和MIPS不同，rcore没有规定地址空间中哪个部分属于内核，哪个属于应用程序。而是内核有一个内核地址空间，每个应用有一个用户地址空间。因此只需要在Trap时进行地址空间的切换，而任务切换时不需要。

> MIPS的设计思路是，每个应用都有一个包含应用和内核的地址空间。这样Trap 的时候无需切换地址空间，而在任务切换的时候才需要切换地址空间。这也有缺点，例如限制了应用的并发和一些安全性问题（隔离性差）

* 将Trap上下文保存在应用地址空间而非内核栈的原因

如果将Trap上下文保存在内核栈，则需要两个中转寄存器：

1. 保存应用地址空间的token(satp寄存器的内容)，因为要将内核地址空间的token写入satp
2. 保存应用的用户栈栈顶，也就是之前的`csrrw sp, sscratch, sp`

然后我们只有sscratch一个寄存器，因此不能这样做，只好保存到应用地址空间了。

* 切换地址空间

切换地址空间是在trap到S态后，在`__alltrap`函数中实现的。

* 切换地址空间的平滑性的保证

每个地址空间最高页面是一个跳板页面，跳板页面对应的物理页帧存放的就是`__alltrap`和`__restore`的汇编代码。因此可以保证平滑性。

## 超越物理内存的地址空间

最合适的方法是采用虚拟内存技术。不过需要一系列的页面置换机制：

- 作为交换区的存储设备：用于存放换出的部分物理内存中的代码和数据。

需要页表项中增加几个信息：

该数据所对应的存储设备的扇区地址。一般页是扇区的整数倍，因此数据对应的扇区地址是好做的。

该数据的虚拟页是否有对应的物理页，用存在位标识。

- 页表项存在位：当应用程序(也可称为任务)访问被换出到交换区的物理内存（对应页表项的存在位为“0”）时，处理器会产生访存异常，让操作系统完成内存换入操作。
- 内存访问异常处理： 操作系统判断任务的访存异常的地址是否属于任务地址空间，如果是属于，则把交换区对应物理内存页换入内存，使得任务可以继续正常运行。

## 问题

- [ ] 比较MOS和rcore这两种地址空间设置方案的不同点。
- [ ] S和U特权级是在哪个寄存器设置的？
- [x] __alltrap函数中，在应用地址空间就可以切换内核页表，那如果一个应用自己就切换了，岂不会带来安全性问题？

修改satp寄存器（S级特权寄存器）需要CPU处于S态。因此不可能在U态切换

- [x] taskContext和TrapContext的区别是什么

taskContext是保存任务切换时的上下文，trapContext是保存trap到S态时的上下文。

- [ ] 内核栈的作用是什么

- [x] 目前rcore的启动流程为:

![image-20230830191501962](https://mdpics4lgw.oss-cn-beijing.aliyuncs.com/aliyun/202308301915345.png)
