# 2.批处理系统

批处理系统的出现，是为了解决计算机出现初期，在一个应用程序运行结束直到下一个应用程序开始运行的这段时间，需要操作员取出上一个程序的执行结果并手动进行穿孔卡片的替换，极大浪费了CPU计算资源。

## 特权级

RISC-V提供了3种特权级：U(用户态)、S(操作系统)、M（监督模式）。

实现特权级机制的根本原因是应用程序运行的安全性不可充分信任。实现特权级机制的主要目的是：

1. 应用程序不能访问任意的地址空间

2. 应用程序不能执行某些可能破坏计算机系统的指令。

   有2类属于S级的特权指令：

   指令本身属于高特权级的指令，如 `sret` 

   指令访问S特权级下的寄存器或内存，如sstatus

通过`ecall`和`eret`，可以实现用户态和内核态的转变。

## 应用程序的实现

应用程序的设计实现要点是：

- 应用程序的内存布局
- 应用程序发出的系统调用

内存布局通过linker.ld说明，程序的起始物理地址调整为 `0x80400000`。

> 构建程序时就按这个来，虽然之后该程序会被拷贝到内核中，但一些绝对地址之前要确定，因此必须和内核相一致。

系统调用则需要注意ABI接口规范，应用程序执行`ecall`，寄存器`a0-a6`保存参数，`a7`保存系统调用号，`a0`再保存返回值。

> RISC-V 寄存器编号从 `0~31` ，表示为 `x0~x31` 。 其中：
>
> - `x10~x17` : 对应 `a0~a7`
> - `x1` ：对应 `ra`，表示返回地址

## 批处理系统的实现

批处理系统是指，每当一个应用执行完毕，我们都需要将下一个要执行的应用的代码和数据加载到内存，然后接着执行下一个应用。

因此首先需要实现应用加载机制，使得系统容易找到这些应用的位置。rcore采用了两种技巧：

- 静态绑定：通过一定的编程技巧，把多个应用程序代码和批处理操作系统代码“绑定”在一起。
- 动态加载：基于静态编码留下的“绑定”信息，操作系统可以找到每个应用程序文件二进制代码的起始地址和长度，并能加载到内存中运行。

### 静态绑定-将应用程序链接到内核

我们已经有了应用程序的二进制镜像，通过汇编代码可以将其作为内核的数据段链接到内核中。链接方法就是通过在main.rs文件中加入指令：

```rust
global_asm!(include_str!("link_app.S"));
```

其中`link_app.S`文件是make run时自动生成的。之后内核通过`_num_app`变量就可以知道应用程序的数量和它们的位置（代码所在的位置）。

### 动态加载-将应用程序二进制码加载到内存

`os`中的`batch`模块实现的AppManager可以实现动态加载功能。

AppManager应该是一个全局变量，而且其中的值应该可以修改。但如果采用`static mut`，则对其访问都会是unsafe的。因此可以通过`static`+`RefCell`来实现，RefCell可以在变量本身不可变的情况下在运行时修改该变量。

不过RefCell未实现Sync特征，不能安全地在线程中共享，不能作为全局变量使用。解决办法就是通过一个UPSafeCell的wrapper来包装RefCell，为UPSafeCell实现Sync特征。我们自己保证它在单核上运行。

> 这其实是一种编程风格，当需要一个全局实例时，而内部的某些字段需要被改变，就可以采用UPSafeCell或RefCell来实现。

在AppManager中，有个load_app方法，内部执行了`fence.i`指令，指示指令缓存要更新，以防修改指令所在内存后，指令缓存并未改变。

## 特权级的切换

对于本OS，只有2个特权级，U和S级。如果Trap到S级，那么OS会使用S级中的控制状态寄存器CSR辅助Trap处理。例如：

| CSR 名  | 该 CSR 与 Trap 相关的功能                                    |
| ------- | ------------------------------------------------------------ |
| sstatus | `SPP` 等字段给出 Trap 发生之前 CPU 处在哪个特权级（S/U）等信息 |
| sepc    | 当 Trap 是一个异常的时候，记录 Trap 发生之前执行的最后一条指令的地址 |
| scause  | 描述 Trap 的原因                                             |
| stval   | 给出 Trap 附加信息                                           |
| stvec   | 控制 Trap 处理代码的入口地址                                 |

### 1.硬件执行-切换特权级

特权级发生切换时，首先是硬件进行如下操作（之后才是软件的事，比如保存上下文啥的）：

* CPU执行ecall时（从U->S）

1. `sstatus` 的 `SPP` 字段会被修改为 CPU 当前的特权级（U级）
2. `sepc` 会被修改为 Trap 处理完成后默认会执行的下一条指令的地址
3. `scause/stval` 分别会被修改成这次 Trap 的原因以及相关的附加信息
4. CPU 会跳转到 `stvec` 所设置的 Trap 处理入口地址，并将当前特权级设置为 S ，然后从Trap 处理入口地址处开始执行。

* CPU执行sret返回时(S->U)

1. CPU 会将当前的特权级按照 `sstatus` 的 `SPP` 字段设置为U或S，这种情况下会设置为U级。
2. CPU 会跳转到 `sepc` 寄存器指向的那条指令，然后继续执行

### 2.软件执行-Trap管理

当硬件执行完后，操作系统会依次完成如下操作：

1. 在Trap处理入口函数__alltraps中，保存被打断的应用程序的 Trap 上下文到TrapContext结构体中，该结构体位于内核栈上。
2. 跳转到trap_handler函数，根据scause寄存器进行异常分发
3. trap_handler执行完后，返回__alltraps，开始执行\_\_restore的代码，恢复上下文

### 用户栈与内核栈

原始控制流的寄存器状态一般要保存在内核栈，而不是用户程序的用户栈。这主要是为了**安全**：如果两个控制流（即应用程序的控制流和内核的控制流）使用同一个栈，在返回之后应用程序就能读到 Trap 控制流的历史信息，带来安全隐患。

> 因此，Acreos应该不需要两个栈吧？