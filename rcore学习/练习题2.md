# 练习题2

## 实践作业

在sys_write函数中增加这样一行代码即可：

```rust
if !((buf as usize >= APP_BASE_ADDRESS && buf as usize + len <= APP_BASE_ADDRESS + APP_SIZE_LIMIT) || 
     (buf as usize >= USER_STACK.get_sp() - USER_STACK_SIZE && buf as usize + len <= USER_STACK.get_sp())) {
    return -1;
}
```

需要注意的是，USER_STACK并不是位于用户程序所在的空间，而是在内核中的全局数据段.data中。

## 问答作业

### 1

在os目录下执行make run TEST=0时，会进入user目录执行make build TEST=0，其中的filter-out是个反过滤函数，将非test开头的文件作为应用程序。

程序出错行为依次为：

```
[kernel] Loading app_0
[kernel] PageFault in application, core dumped.
[kernel] Loading app_1
[kernel] IllegalInstruction in application, core dumped.
[kernel] Loading app_2
[kernel] IllegalInstruction in application, core dumped.
```

### 2

1. 刚进入`__restore`时，`a0`代表内核栈栈顶。其两种使用场景分别是：
   * 当系统调用返回到用户态时，restore上下文
   * 当执行用户程序时，从S态变为U态，并初始化寄存器
2. 特殊处理了sstatus、sepc、sscratch寄存器。sstatus指明了要返回U态、sepc指明了返回U态后取址地址、sscratch中则存放了用户栈栈顶
3. x2为sp寄存器，在之后会和sscratch交换，得到真正的用户栈栈顶，现在恢复的值没有意义；x4为一个没用的寄存器，不需要恢复
4. sp此时的值是用户栈栈顶，sscratch为内核栈栈顶
5. sret发生状态切换。该指令会将CPU当前特权级按sstatus中的SPP字段进行设置。
6. sp表示内核栈栈顶，sscratch表示用户栈栈顶
7. ecall

