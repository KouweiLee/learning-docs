# 3.多道程序与分时多任务

多道程序出现的原因，是批处理系统依次执行应用程序导致CPU利用率不高，主要原因在于IO操作时间慢，应用程序会忙等。

## 多道程序的放置和加载

一个程序执行完毕后或主动放弃执行，处理器才能执行另外一个程序。我们把这种运行方式称为 **多道程序（Multiprogramming）** 。

多道程序要同时放入内存里，因此构建时每个程序的基地址应该依次排布，思路就是每个程序占据固定大小为APP_SIZE_LIMIT的大小，所有程序依次从APP_BASE_ADDRESS开始排步。

具体在构建时采用了build.py构建脚本，每次会修改linker.ld的基地址，保证构建出的elf文件中程序基地址满足上述条件。

之后在main.rs中将这些应用程序镜像文件一起依次加载到内存里即可。

## 任务切换

任务切换支持应用在运行途中交出CPU使用权，使其他应用进行执行。

* 任务切换时需要保存什么

任务是指应用程序的一次执行过程。任务切换时也需要保存上下文（任务上下文），不同于Trap时保存的上下文，任务切换实际上是两个内核控制流的切换，它通过调用`__switch`函数实现，因此只需要按照risc-v调用规范为`__switch`这个函数保存需要保存的寄存器，也就是ra、sp、s0-s11（被调用者需保存的寄存器），其他寄存器都保存在属于该任务内核控制流的内核栈上了。

* 任务上下文保存在哪里

任务上下文保存的位置是在`TaskManager`中数组tasks里，以TaskContext的形式保存。

* 任务切换的具体流程

当一个应用程序让出CPU的执行权时会进入内核态，S态首先保存TrapContext，之后执行`__switch`函数，`__switch`函数接收两个参数，当前TaskContext和接下来要执行的TaskContext指针，之后将任务上下文保存在当前TaskContext中，然后恢复要执行的TaskContext到CPU寄存器中，执行ret返回到内核Trap处理程序中即可。

## 多道程序与协作式调度

内核需要记录每个应用（任务）的状态，上下文，因此需要一个全局的任务管理者TASK_MANAGER，保存所有任务的任务控制块。

* 第一个应用程序的运行

第一次运行应用程序时，TASK_MANAGER会初始化每个task的TaskContext，使其`ra`为`__restore`函数，`sp`为每个程序内核栈栈顶指针， 此时内核栈已经保存了TrapContext。之后执行`run_first_task`函数。该函数调用`__switch`后，task 0会跳转到`__restore`继续执行。`run_first_task`永远不会返回。

* 应用程序的切换

应用程序执行`yield_`函数，会执行`sys_yield`系统调用，最终转到`suspend_current_and_run_next`函数，该函数调用`run_next_task`函数，之后调用`__switch`来切换应用程序。

## 分时多任务与抢占式调度

通过时钟中断就可以实现。时钟中断对M态的寄存器进行设置即可。

