# 8.并发

操作系统中常见的同步互斥操作：

1. 互斥锁：Mutex
2. 条件变量：一种同步原语，用于多个线程的协作，Condvar
3. 信号量：用于共享资源的互斥访问，rust中没有信号量类型，可以通过Mutex和Condvar构造

## 用户态下的线程

线程机制可以在用户态下运行，这是OS感知不到线程的存在。要在用户态下创建线程，需要先建立多线程的基本执行环境：

1. 定义线程的结构和执行状态：线程上下文和执行状态
2. 建立“线程管理运行时”数据结构，并初始化：提供线程创建和线程切换的功能

代码参见user/src/bin/stackful_coroutine.rs文件。

- [ ] 在TaskContext中，x1和nx1都表示返回地址，它们的作用和区别是什么？

在spawn函数里，x1是当该线程执行完成后要返回的地址，nx1则是线程开始执行的指令地址。spawn函数执行完成后，子线程还不会执行，只有在runtime执行run函数后，第一个子线程才会开始执行。

> 线程id为0的线程表示主线程，就是runtime

执行run函数会调用t_yield函数，该函数切换当前线程和下一个线程的状态，并通过switch函数，将当前执行状态保存在当前线程上下文中，将下一个线程上下文恢复到CPU寄存器里。特别地，CPU当前的ra保存在上下文的x1和nx1寄存器里，而新进程上下文的x1恢复到ra中，并跳转到nx1。

那么对于主线程再次恢复执行时，由于执行switch函数

## 内核态下的线程管理

用户态执行线程管理的不足在于，线程只能主动让出CPU使用权。

## 互斥锁

## 条件变量

在并发编程时，要特别小心带着锁进入阻塞的情形。

而我们需要解决的一类同步互斥问题是：

1. 线程共享一些资源，需要用互斥锁进行保护
2. 基于阻塞机制实现线程之间的条件同步。

因此，人们就提出了管程和条件变量：

管程是一个由过程（函数）、共享变量及数据结构等组成的一个集合。线程通过调用管程提供的过程，而不能直接访问共享资源。

条件变量的wait函数执行如下：

- 释放锁；
- 阻塞当前线程；
- 当前线程被唤醒之后，重新获取到锁。
- `wait` 返回，当前线程成功向下执行。

signal函数采用Mesa语义，当发现条件满足时，signal唤醒一个`T2`线程，但不会将锁转交给`T2`。只有该线程退出管程释放锁后，`T2`才会与其他线程竞争直到抢到锁。
