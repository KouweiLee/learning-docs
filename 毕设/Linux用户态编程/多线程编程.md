# 多线程编程学习

## 线程的创建

```c
extern int pthread_create (pthread_t *__restrict __newthread,
			   const pthread_attr_t *__restrict __attr,
			   void *(*__start_routine) (void *),
			   void *__restrict __arg) __THROWNL __nonnull ((1, 3));
```

**参数:**

- `pthread_t *__restrict __newthread` ： 该**线程的名字**，类型为`pthread_t *`，此处需要注意是名字的指针变量，因此传递的时候需要对名字做取地址操作。
- `const pthread_attr_t *__restrict __attr` ： 该**线程的属性**，没有特殊情况时使用`NULL`即可。线程的属性可以定义线程的栈大小，调度优先级等
- `void *(*__start_routine) (void *)` ： 该**线程的函数**，类型为`void *` ，因为函数名本身就是该函数的地址，所以可以直接传入一个具体的函数名，供该线程执行。需要注意的是，该函数必须为`void *`类型返回值的函数。
- `void *__restrict __arg` ： 要传入该线程的参数，必须为`void *`类型，如果没有需要传递的参数，则传入`NULL`.

**返回值:**

- 0 ： 表示线程创建成功。
- !0： 表示线程创建失败，返回的非0值都对应不同的宏，表明失败的原因：
  - EAGAIN：系统资源不足，无法提供创建线程所需的资源。
  - EINVAL：传递给 pthread_create() 函数的 attr 参数无效。
  - EPERM：传递给 pthread_create() 函数的 attr 参数中，某些属性的设置为非法操作，程序没有相关的设置权限。

## 线程同步

线程同步机制也称为线程之间的锁机制，其目的是限制对公共资源的访问。C语言常用的线程间同步机制有四种：

- 互斥锁
- 信号量
- 条件变量
- 读写锁

### 互斥锁

#### 创建互斥锁

初始化互斥锁分有两种方式:

1. 静态初始化

   ```c
   pthread_mutex_t audio_mutex = PTHREAD_MUTEX_INITIALIZER;
   ```

   静态初始化的互斥锁在静态存储区，初始化之后可以直接使用，不使用了也不需要进行删除和释放。

2. 动态初始化

   ```c
   pthread_mutex_t audio_mutex;
   pthread_mutex_init(&audio_mutx, NULL);
   ```

   动态初始化在堆内存区，互斥锁使用完毕之后需要进行销毁释放。

动态初始化的函数原型为:

```c
extern int pthread_mutex_init (pthread_mutex_t *__mutex, const pthread_mutexattr_t *__mutexattr)
```

`const pthread_mutexattr_t *__mutexattr` 互斥锁属性，一般情况下初始化使用NULL，即默认属性即可。

- `PTHREAD_MUTEX_TIMED_NP` 就是普通锁。当一个线程加锁以后，其余请求锁的线程将形成一个等待队列，并在解锁后按优先级获得锁。这种锁策略保证了资源分配的公平性。
- `PTHREAD_MUTEX_RECURSIVE_NP` 允许同一个线程对同一个锁成功获得多次，并通过多次unlock解锁。如果是不同线程请求，则在加锁线程解锁时重新竞争。
- `PTHREAD_MUTEX_ERRORCHECK_NP` 如果同一个线程请求同一个锁，则返回EDEADLK，否则与PTHREAD_MUTEX_TIMED_NP类型动作相同。这样就保证当不允许多次加锁时不会出现最简单情况下的死锁。
- `PTHREAD_MUTEX_ADAPTIVE_NP` 动作最简单的锁类型，仅等待解锁后重新竞争

对锁属性的操作函数:

![image-20231114173358982](https://klelee-images.oss-cn-qingdao.aliyuncs.com/typora/image-20231114173358982.png)

#### 销毁互斥锁

使用`pthread_mutex_init()`函数初始化互斥锁之后需要特别的使用`pthread_mutex_destroy();`来销毁互斥锁.

```c
extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
     __THROW __nonnull ((1));
```

#### 加锁和解锁

加锁分有:

- 阻塞加锁： 如果该锁已经被别的线程持有，则阻塞等待锁被释放

  ```c
  extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
  ```

- 非阻塞加锁：如果该锁已经被别的线程持有，则返回 `EBUSY`

  ```c
  extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
  ```

  加锁成功返回0，加锁失败返回`EBUSY`

解锁函数为:

```c
extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
```

返回0表示解锁成功，否则解锁失败

### 条件变量

什么是条件变量？条件变量用于一个线程通知其他线程某个条件成立．如果条件不成立，其他线程会阻塞，不会轮询而白白占用ＣＰＵ时间．条件一旦成立，那么会有线程被唤醒。由于多个线程可能竞争地访问临界资源，因此使用条件变量常伴随着使用一个互斥锁，来保证如果有多个线程被唤醒时，只会有一个线程获得锁。

#### 创建条件变量

条件变量的声明和初始化：

```c
#include <pthread.h>
pthread_conf_t testCond;

/* Initialize condition variable COND using attributes ATTR, or use
   the default values if later is NULL.  */
extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
			      const pthread_condattr_t *__restrict __cond_attr);
```

#### 等待条件成立

```c
/// 功能：对当前进程的指定条件变量进行 wait 操作，分为多个阶段：
/// 1. 释放当前线程持有的一把互斥锁；
/// 2. 阻塞当前线程并将其加入指定条件变量的阻塞队列；
/// 3. 直到当前线程被其他线程通过 signal 操作唤醒；
/// 4. 重新获取当前线程之前持有的锁。
extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
			      pthread_mutex_t *__restrict __mutex);
```

执行该函数前，需要保证该线程已获得`__mutex`锁。

#### 使条件成立的函数

使条件成立，也就是唤醒被阻塞在条件变量上的线程。signal函数只释放一个，具体释放哪个是OS决定的。broadcast会把所有都释放，但由于wait函数在返回时必须获得锁，因此一次只能有一个线程真正地返回。

```c
/* Wake up one thread waiting for condition variable COND.  */
extern int pthread_cond_signal (pthread_cond_t *__cond)__THROWNL __nonnull ((1));

/* Wake up all threads waiting for condition variables COND.  */
extern int pthread_cond_broadcast (pthread_cond_t *__cond)__THROWNL __nonnull ((1));
```

由于这两个函数都没有接受锁作为参数，因此这两个函数既不会获取锁，也不会释放锁。下面的例子是使用条件变量时较为常见的：

```c
thread1:
    pthread_mutex_lock(&mutex);
    // 使用while的原因是，多个线程A、B如果都等待这个条件，可能线程A先返回，改变了这个条件，那么在线程B返回时条件已经不成立了
    while (!condition)
        pthread_cond_wait(&cond, &mutex);
    // do something that requires holding the mutex and condition is true
    pthread_mutex_unlock(&mutex);

thread2:
    pthread_mutex_lock(&mutex);
    // do something that might make condition true
    pthread_cond_signal(&cond);
    pthread_mutex_unlock(&mutex);
```



## 参考资料

https://www.cnblogs.com/klelee/p/c_thread.html