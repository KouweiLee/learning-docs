# Linux信号机制

## 信号的基本概念

信号可以理解为一种针对用户程序的软件中断, 可以用于异步通信. 信号的产生有多种方式:

1. 进程调用kill系统调用向指定进程发信号
2. 内核通过send_signal等函数向指定进程发信号

LInux支持0-64个信号, 其中0-31号信号为标准信号, 又称不可靠信号, 因为如果此时进程的信号处理队列中存在了某个信号, 当这个信号这时再次发生时, 则会被忽略；32-64为可靠信号, 所有收到的信号都会被处理. 

<img src="https://mdpics4lgw.oss-cn-beijing.aliyuncs.com/aliyun/image-20240110110129566.png" alt="image-20240110110129566" style="zoom: 50%;" />

* 信号的属性

阻塞: 如果一个信号被阻塞, 它还是会加入到进程的信号处理队列中, 但在没有取消阻塞前, 不会被处理. 一旦取消阻塞, 就会被处理. 所以又称为暂时屏蔽. 通过sigaction和sigprocmask函数可以设定信号的阻塞. 

忽略: 被忽略的信号, 还是会被处理, 不过信号处理函数是空的. 

### 信号的处理

信号的处理时机: 信号是在线程将要返回用户空间之前进行处理的, 可能是从系统调用返回, 也可能是从中断返回, 返回之前，线程会检查队列里有没有信号要处理，有的话就处理。

信号的注销:  调用信号处理函数之前，进程会把信号在未决信号链中的sigqueue结构卸掉。是否从未决信号集中把信号删除掉，对于实时信号与非实时信号是不相同的。

信号处理函数完成后: 信号处理函数结束时, 会进入内核态, 再次检查是否有信号要处理. 如果没有, 则恢复原来用户态的上下文.

## 用户态设置信号处理函数

设置信号处理方式的接口函数有两个，signal和sigaction。signal是早期的设置函数，适用于标准信号，比较简单。sigaction是后来新增的接口函数，功能比较强大，适用于实时信号，当然也可以用于标准信号。

* signal()函数

```c
sighandler_t signal(int signum, sighandler_t handler);
```

signal有两个参数，第一个是信号数值，第二个是信号处理函数。信号处理函数的接口如下所示：

```c
typedef void (*sighandler_t)(int);
```

第二个参数可以传递特殊值SIG_IGN，代表忽略这个信号，还可以传递特殊值SIG_DFL，代表恢复信号的默认处理方式。

* sigaction()函数

```c
int sigaction(int signum, const struct sigaction *restrict act, struct sigaction *restrict oldact);
```

第一个参数是信号数值，第二个参数是要设置的情况，第三个参数会返回旧的设置情况，可以为NULL. 其中sigaction结构体为:

```c
struct sigaction {
    void     (*sa_handler)(int);
    void     (*sa_sigaction)(int, siginfo_t *, void *);// 
    sigset_t   sa_mask;
    int        sa_flags;
    void     (*sa_restorer)(void);
};
```

前2个参数为信号处理函数指针, 如果在字段sa_flags里面设置SA_SIGINFO的话就使用sa_sigaction, 否则是sa_handler. 

sa_mask: 信号处理函数在**执行时**阻塞哪些信号. 这里的阻塞指的是当信号处理函数执行过程中, 发生trap到内核并返回时, 内核不会执行这些信号的处理函数, 而是继续执行当前的信号处理函数. 然而, 这些被阻塞的信号仍然会加入到进程的未决信号队列中. 当前信号处理函数执行完后, 这些被阻塞的信号还会被处理. 

* sigprocmask()函数

`sigaction()`函数可以用来设置某个信号处理例程的信号掩码, 而 `sigprocmask` 是设置这个进程的全局信号掩码:

```c
int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
```

参数:

* how: 控制sigprocmask的行为. SIG_BLOCK: 阻塞信号集为参数set和当前set的并集；SIG_UNBLOCK: 从当前set集中取消参数set指定的信号的阻塞；SIG_SETMASK: 阻塞信号集为参数set.

多线程环境下要使用pthread_sigmask函数. 

## 从内核向用户态发信号

TODO

## 问题

- [x] 如果一个信号处理函数正在执行, 又有信号发来, 如何确保这些信号所表示的信息都被处理了呢

改成可靠信号, 但有一个问题, 中断返回后第一个信号处理函数咋办呢? 

信号处理过程中, 通过sigaction已经设定了阻塞所有信号, 因此还是会执行第一个信号处理函数. 

- [ ] 对于el0和el2共享的内存, 必须要保证不会出现同时写一个地方的错误, 而这可以通过只让el2写, 或者el0写. 比如finish req的时候让el2来更新. 
- [x] 信号是在处理完之后从信号队列中取出吗

不是, 信号的注销是在调用信号处理函数之前. 调用信号处理函数之前，进程会把信号在未决信号链中的sigqueue结构卸掉。是否从未决信号集中把信号删除掉，对于实时信号与非实时信号是不相同的。参见: https://zhuanlan.zhihu.com/p/266427607

- [x] 信号处理时发生了中断, 那么之后中断返回时还会执行信号处理函数吗?

会. sigaction屏蔽了其他信号在信号处理函数未执行完时. 

- [ ] 利用多线程来处理信号: https://zhuanlan.zhihu.com/p/266427607的最后. 不过要考虑可重入的问题

## 参考资料

1. https://embetronicx.com/tutorials/linux/device-drivers/sending-signal-from-linux-device-driver-to-user-space/
1. 在命令行中输入man sigaction
1. https://zhuanlan.zhihu.com/p/266427607
1. https://zhuanlan.zhihu.com/p/537431439